<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üí£ D√©mineur - Spring Boot</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <header>
        <h1>üí£ D√©mineur - Spring Boot</h1>
        <div class="api-status" id="apiStatus">üîå Connexion API...</div>
    </header>

    <div class="top-panel">
        <div class="info-boxes">
            <div class="info-box mines">
                <label>üí£ Mines</label>
                <div class="value" id="minesCount">10</div>
            </div>
            <div class="info-box status">
                <label>üéÆ Statut</label>
                <div class="value" id="gameStatus">En attente...</div>
            </div>
            <div class="info-box timer">
                <label>‚è±Ô∏è Temps</label>
                <div class="value" id="timer">0s</div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-warning" onclick="showScoreboard()">üèÜ Scores</button>
            <button class="btn-primary" onclick="showNewGameModal()">üîÑ Nouvelle Partie</button>
        </div>
    </div>

    <div class="center">
        <div class="game-area">
            <div class="board" id="board"></div>
        </div>
    </div>

    <div class="bottom-panel">
        <div class="player-info">üë§ <span id="playerName">Joueur</span></div>
        <button class="btn-success" onclick="revealSafeCell()">üí° Indice</button>
        <button class="btn-primary" onclick="changePseudo()">Changer de pseudo</button>
    </div>
</div>

<!-- Modal Pseudo -->
<div class="modal" id="pseudoModal">
    <div class="modal-content">
        <h2>Bienvenue !</h2>
        <label>Entrez votre pseudo :</label>
        <input type="text" id="pseudoInput" placeholder="Votre pseudo" maxlength="50">
        <div class="modal-buttons">
            <button class="btn-primary" onclick="setPseudo()">Commencer</button>
        </div>
    </div>
</div>

<!-- Modal Nouvelle Partie -->
<div class="modal" id="newGameModal">
    <div class="modal-content">
        <h2>Nouvelle Partie</h2>
        <label>Choisir la difficult√© :</label>
        <select id="difficulty">
            <option value="beginner">üü¢ D√©butant (9√ó9, 10 mines)</option>
            <option value="intermediate">üü° Interm√©diaire (16√ó16, 40 mines)</option>
            <option value="expert">üî¥ Expert (16√ó30, 99 mines)</option>
            <option value="custom">‚öôÔ∏è Personnalis√©</option>
        </select>
        <div id="customSettings" style="display:none;">
            <label>Lignes (5-40):</label>
            <input type="number" id="customRows" min="5" max="40" value="9">
            <label>Colonnes (5-60):</label>
            <input type="number" id="customCols" min="5" max="60" value="9">
            <label>Mines:</label>
            <input type="number" id="customMines" min="1" value="10">
        </div>
        <div class="modal-buttons">
            <button class="btn-primary" onclick="startNewGame()">D√©marrer</button>
            <button class="btn-warning" onclick="closeModal('newGameModal')">Annuler</button>
        </div>
    </div>
</div>

<!-- Modal Scoreboard -->
<div class="modal" id="scoreboardModal">
    <div class="modal-content" style="max-width: 800px;">
        <h2>üèÜ Tableau des Scores</h2>
        <div class="scoreboard" id="scoreboardContent">
            <p>Chargement...</p>
        </div>
        <div class="modal-buttons">
            <button class="btn-primary" onclick="closeModal('scoreboardModal')">Fermer</button>
        </div>
    </div>
</div>

<script>
    // Configuration de l'API
    const API_URL = 'https://minesweeper.btsinfo.nc/api';

    // Variables du jeu
    let rows = 9, cols = 9, mineCount = 10;
    let cells = [];
    let gameStarted = false;
    let gameOver = false;
    let revealedCount = 0;
    let flags = 0;
    let seconds = 0;
    let timerInterval = null;
    let currentDifficulty = "D√©butant";
    let playerPseudo = "Joueur";

    // V√©rifier la connexion API au d√©marrage
    document.addEventListener('DOMContentLoaded', () => {
        checkApiHealth();

        document.getElementById('difficulty').addEventListener('change', (e) => {
            document.getElementById('customSettings').style.display =
                e.target.value === 'custom' ? 'block' : 'none';
        });

        showModal('pseudoModal');
    });

    async function checkApiHealth() {
        try {
            const response = await fetch(`${API_URL}/health`);
            const data = await response.json();

            if (data.success) {
                document.getElementById('apiStatus').textContent = '‚úÖ API Connect√©e';
                document.getElementById('apiStatus').classList.remove('offline');
                console.log('‚úì Connexion API r√©ussie');
            }
        } catch (error) {
            document.getElementById('apiStatus').textContent = '‚ùå API D√©connect√©e';
            document.getElementById('apiStatus').classList.add('offline');
            console.error('‚úó Erreur de connexion API:', error);
            alert('‚ö†Ô∏è Impossible de se connecter au serveur.\nAssurez-vous que le backend Spring Boot est d√©marr√© sur le port 8080.');
        }
    }

    function showModal(id) {
        document.getElementById(id).classList.add('active');
    }

    function closeModal(id) {
        document.getElementById(id).classList.remove('active');
    }

    function setPseudo() {
        const input = document.getElementById('pseudoInput').value.trim();
        if (input) {
            playerPseudo = input;
            document.getElementById('playerName').textContent = playerPseudo;
        }
        closeModal('pseudoModal');
        startNewGame();
    }

    function changePseudo() {
        document.getElementById('pseudoInput').value = playerPseudo;
        showModal('pseudoModal');
    }

    function showNewGameModal() {
        showModal('newGameModal');
    }

    function startNewGame() {
        const difficulty = document.getElementById('difficulty').value;

        switch(difficulty) {
            case 'beginner':
                rows = 9; cols = 9; mineCount = 10;
                currentDifficulty = "D√©butant";
                break;
            case 'intermediate':
                rows = 16; cols = 16; mineCount = 40;
                currentDifficulty = "Interm√©diaire";
                break;
            case 'expert':
                rows = 16; cols = 30; mineCount = 99;
                currentDifficulty = "Expert";
                break;
            case 'custom':
                rows = Math.max(5, Math.min(40, parseInt(document.getElementById('customRows').value)));
                cols = Math.max(5, Math.min(60, parseInt(document.getElementById('customCols').value)));
                mineCount = Math.max(1, parseInt(document.getElementById('customMines').value));
                mineCount = Math.min(mineCount, rows * cols - 1);
                currentDifficulty = "Personnalis√©";
                break;
        }

        closeModal('newGameModal');
        initGame();
    }

    function initGame() {
        gameStarted = false;
        gameOver = false;
        revealedCount = 0;
        flags = 0;
        seconds = 0;

        if (timerInterval) clearInterval(timerInterval);

        document.getElementById('minesCount').textContent = mineCount;
        document.getElementById('timer').textContent = '0s';
        document.getElementById('gameStatus').textContent = 'En attente...';

        createBoard();
    }

    function createBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        board.style.gridTemplateColumns = `repeat(${cols}, 40px)`;

        cells = [];
        for (let r = 0; r < rows; r++) {
            cells[r] = [];
            for (let c = 0; c < cols; c++) {
                const cell = {
                    row: r,
                    col: c,
                    isMine: false,
                    adjacent: 0,
                    revealed: false,
                    flagged: false,
                    element: null
                };

                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                cellDiv.dataset.row = r;
                cellDiv.dataset.col = c;

                cellDiv.addEventListener('click', () => handleLeftClick(r, c));
                cellDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleRightClick(r, c);
                });

                cell.element = cellDiv;
                cells[r][c] = cell;
                board.appendChild(cellDiv);
            }
        }
    }

    function placeMines(avoidRow, avoidCol) {
        const forbidden = new Set();
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                const r = avoidRow + dr;
                const c = avoidCol + dc;
                if (r >= 0 && r < rows && c >= 0 && c < cols) {
                    forbidden.add(`${r},${c}`);
                }
            }
        }

        let placed = 0;
        while (placed < mineCount) {
            const r = Math.floor(Math.random() * rows);
            const c = Math.floor(Math.random() * cols);

            if (forbidden.has(`${r},${c}`) || cells[r][c].isMine) continue;

            cells[r][c].isMine = true;
            placed++;
        }

        // Calculate adjacent mines
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (cells[r][c].isMine) continue;

                let count = 0;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr;
                        const nc = c + dc;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && cells[nr][nc].isMine) {
                            count++;
                        }
                    }
                }
                cells[r][c].adjacent = count;
            }
        }
    }

    function handleLeftClick(r, c) {
        if (gameOver) return;

        const cell = cells[r][c];
        if (cell.revealed || cell.flagged) return;

        if (!gameStarted) {
            placeMines(r, c);
            gameStarted = true;
            startTimer();
            document.getElementById('gameStatus').textContent = 'En jeu...';
        }

        revealCell(r, c);
    }

    function handleRightClick(r, c) {
        if (gameOver || !gameStarted) return;

        const cell = cells[r][c];
        if (cell.revealed) return;

        cell.flagged = !cell.flagged;
        flags += cell.flagged ? 1 : -1;

        cell.element.classList.toggle('flagged', cell.flagged);
        cell.element.textContent = cell.flagged ? 'üö©' : '';

        document.getElementById('minesCount').textContent = Math.max(0, mineCount - flags);
    }

    function revealCell(r, c) {
        const cell = cells[r][c];
        if (cell.revealed || cell.flagged) return;

        cell.revealed = true;
        revealedCount++;
        cell.element.classList.add('revealed');

        if (cell.isMine) {
            cell.element.textContent = 'üí£';
            cell.element.classList.add('mine-hit');
            gameLost();
            return;
        }

        if (cell.adjacent > 0) {
            cell.element.textContent = cell.adjacent;
            cell.element.classList.add(`num-${cell.adjacent}`);
        }

        if (cell.adjacent === 0) {
            // Flood fill
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        revealCell(nr, nc);
                    }
                }
            }
        }

        checkWin();
    }

    function revealSafeCell() {
        if (!gameStarted || gameOver) return;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const cell = cells[r][c];
                if (!cell.revealed && !cell.isMine && !cell.flagged) {
                    revealCell(r, c);
                    return;
                }
            }
        }
    }

    function checkWin() {
        if (revealedCount === rows * cols - mineCount) {
            gameOver = true;
            stopTimer();
            document.getElementById('gameStatus').textContent = 'üéâ Victoire !';
            document.getElementById('minesCount').textContent = '0';

            // Reveal all mines as flags
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (cells[r][c].isMine) {
                        cells[r][c].element.textContent = 'üö©';
                        cells[r][c].element.style.background = '#27AE60';
                    }
                }
            }

            saveScore();
        }
    }

    function gameLost() {
        gameOver = true;
        stopTimer();
        document.getElementById('gameStatus').textContent = 'üí• Game Over';

        // Reveal all mines
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (cells[r][c].isMine) {
                    cells[r][c].element.textContent = 'üí£';
                    cells[r][c].element.classList.add('mine');
                }
            }
        }
    }

    function startTimer() {
        timerInterval = setInterval(() => {
            seconds++;
            document.getElementById('timer').textContent = seconds + 's';
        }, 1000);
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }


    function showNotification(message, type) {
        // Cr√©er la notification
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `<strong>${message}</strong>`;
        notification.style.cssText = `
             position: fixed;
             top: 20px;
            right: 20px;
            background: ${type === 'success' ? '#27AE60' : '#E74C3C'};
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 9999;
            animation: slideIn 0.3s;
        `;
    
        document.body.appendChild(notification);
    
        // Supprimer apr√®s 3 secondes
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }

    async function saveScore() {
    try {
        console.log('Envoi du score:', {
            pseudo: playerPseudo,
            difficulte: currentDifficulty,
            temps: seconds
        });

        const response = await fetch(`${API_URL}/scores`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                pseudo: playerPseudo,
                difficulte: currentDifficulty,
                temps: seconds
            })
        });

        console.log('R√©ponse status:', response.status);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Erreur HTTP:', response.status, errorText);
            throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        console.log('Score enregistr√©:', data);

        if (data && data.id) {
            // ‚úÖ Score enregistr√© !
            showNotification('Score enregistr√© avec succ√®s!', 'success');
            setTimeout(() => showTop4(), 1000);
        }
    } catch (error) {
        showNotification('Erreur lors de l\'enregistrement du score: ' + error.message, 'error');
    }

}

    async function loadScores() {
    const difficulty = document.getElementById('scoreDifficulty').value;
    
    try {
       
        const response = await fetch(`${API_URL}/scores/top4/${encodeURIComponent(difficulty)}`);
        
        if (!response.ok) {
            console.error('Erreur HTTP:', response.status);
            const scoresList = document.getElementById('scoresList');
            scoresList.innerHTML = '<p style="text-align: center; color: #999;">Erreur de chargement</p>';
            return;
        }
        
        const data = await response.json();
        
        const scoresList = document.getElementById('scoresList');
        scoresList.innerHTML = '';
        
        if (!data.scores || data.scores.length === 0) {
            scoresList.innerHTML = '<p style="text-align: center; color: #999;">Aucun score enregistr√©</p>';
            return;
        }
        
        data.scores.forEach(score => {
            const medals = ['ü•á', 'ü•à', 'ü•â', 'üèÖ'];
            const medal = medals[score.rang - 1] || 'üèÖ';
            
            const item = document.createElement('div');
            item.className = 'score-item';
            item.innerHTML = `
                <div style="display: flex; align-items: center;">
                    <span class="score-rank">${medal}</span>
                    <div>
                        <strong>${score.pseudo}</strong><br>
                        <small style="color: #666;">${score.date}</small>
                    </div>
                </div>
                <div style="font-size: 1.5em; font-weight: bold; color: #667eea;">
                    ${score.temps}s
                </div>
            `;
            scoresList.appendChild(item);
        });
    } catch (error) {
        console.error('Erreur chargement scores:', error);
        const scoresList = document.getElementById('scoresList');
        scoresList.innerHTML = '<p style="text-align: center; color: red;">Erreur de connexion</p>';
    }
}

    async function showTop4() {
    try {
        const response = await fetch(`${API_URL}/scores/top4/${currentDifficulty}`);
        
        if (!response.ok) {
            console.error('Erreur HTTP:', response.status);
            return;
        }
        
        const data = await response.json();
        
        let message = `üéâ F√©licitations ${playerPseudo}!\n\n`;
        message += `Difficult√©: ${currentDifficulty}\n`;
        message += `Votre temps: ${seconds}s\n\n`;
        message += `üèÜ Top 4 - ${currentDifficulty}:\n\n`;
        
        if (data.scores && data.scores.length > 0) {
            data.scores.forEach(score => {
                const medals = ['ü•á', 'ü•à', 'ü•â', 'üèÖ'];
                const medal = medals[score.rang - 1] || 'üèÖ';
                message += `${medal} ${score.rang}. ${score.pseudo} - ${score.temps}s\n`;
            });
        } else {
            message += 'Vous √™tes le premier sur cette difficult√© !';
        }
        
        alert(message);
    } catch (error) {
        console.error('Erreur chargement top 4:', error);
    }
}    

function showScoresModal() {
    document.getElementById('scoresModal').style.display = 'block';
    loadScores();  // ‚Üê IMPORTANT : Charger les scores √† l'ouverture
}

    async function showTop4After1Min() {
        try {
            const response = await fetch(`${API_URL}/scores/${encodeURIComponent(currentDifficulty)}`);
            const data = await response.json();

            if (data.success && data.scores.length > 0) {
                let message = `üéâ F√©licitations ${playerPseudo} !\n\n`;
                message += `Difficult√©: ${currentDifficulty}\n`;
                message += `Votre temps: ${seconds} secondes\n\n`;
                message += `üèÜ Top 4 - ${currentDifficulty}:\n\n`;

                data.scores.forEach((score) => {
                    const medal = score.rang == 1 ? 'ü•á' : score.rang == 2 ? 'ü•à' : score.rang == 3 ? 'ü•â' : 'üèÖ';
                    message += `${medal} ${score.rang}. ${score.pseudo} - ${score.temps}s (${score.date})\n`;
                });

                alert(message);
            } else {
                alert(`F√©licitations ${playerPseudo} !\nDifficult√©: ${currentDifficulty}\nTemps: ${seconds} secondes\n\nVous √™tes le premier sur cette difficult√© !`);
            }
        } catch (error) {
            console.error('Erreur:', error);
            alert(`F√©licitations ${playerPseudo} !\nDifficult√©: ${currentDifficulty}\nTemps: ${seconds} secondes\n\nVotre score a √©t√© enregistr√© !`);
        }
    }

    async function showScoreboard() {
    const content = document.getElementById('scoreboardContent');
    
    // Cr√©er le menu de s√©lection
    content.innerHTML = `
        <div style="margin-bottom: 20px;">
            <label for="difficultySelect" style="font-weight: bold; margin-right: 10px;">S√©lectionnez une difficult√© :</label>
            <select id="difficultySelect" style="padding: 8px; border-radius: 5px; border: 2px solid #667eea;">
                <option value="D√©butant" ${currentDifficulty === 'D√©butant' ? 'selected' : ''}>üü¢ D√©butant</option>
                <option value="Interm√©diaire" ${currentDifficulty === 'Interm√©diaire' ? 'selected' : ''}>üü° Interm√©diaire</option>
                <option value="Expert" ${currentDifficulty === 'Expert' ? 'selected' : ''}>üî¥ Expert</option>
                <option value="Personnalis√©" ${currentDifficulty === 'Personnalis√©' ? 'selected' : ''}>‚öôÔ∏è Personnalis√©</option>
            </select>
        </div>
        <div id="scoresList" style="margin-top: 20px;">Chargement...</div>
    `;
    
    const select = document.getElementById('difficultySelect');
    
    // ‚úÖ Fonction interne corrig√©e avec le bon endpoint
    async function loadScoresForDifficulty(difficulty) {
        const scoresList = document.getElementById('scoresList');
        try {
            // ‚úÖ Utiliser /scores/top4/{difficulty} comme showTop4()
            const response = await fetch(`${API_URL}/scores/top4/${encodeURIComponent(difficulty)}`);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.scores && data.scores.length > 0) {
                let html = `<h3 style="color: #667eea; margin-bottom: 15px;">Top 4 - ${difficulty}</h3>`;
                html += '<table style="width: 100%; border-collapse: collapse;">';
                html += '<thead><tr style="background: #667eea; color: white;">';
                html += '<th style="padding: 12px; text-align: left;">üèÜ Rang</th>';
                html += '<th style="padding: 12px; text-align: left;">Pseudo</th>';
                html += '<th style="padding: 12px; text-align: center;">Temps</th>';
                html += '<th style="padding: 12px; text-align: center;">Date</th>';
                html += '</tr></thead><tbody>';
                
                data.scores.forEach((score, index) => {
                    const medals = ['ü•á', 'ü•à', 'ü•â', 'üèÖ'];
                    const medal = medals[score.rang - 1] || 'üèÖ';
                    const bgColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                    
                    html += `<tr style="background: ${bgColor};">
                        <td style="padding: 12px;">${medal} ${score.rang}</td>
                        <td style="padding: 12px;"><strong>${score.pseudo}</strong></td>
                        <td style="padding: 12px; text-align: center; font-weight: bold; color: #667eea;">${score.temps}s</td>
                        <td style="padding: 12px; text-align: center; color: #666;">${score.date}</td>
                    </tr>`;
                });
                html += '</tbody></table>';
                scoresList.innerHTML = html;
            } else {
                scoresList.innerHTML = `<p style="text-align: center; color: #999; padding: 20px;">Aucun score enregistr√© pour la difficult√© "${difficulty}"</p>`;
            }
        } catch (error) {
            console.error('Erreur chargement scores:', error);
            scoresList.innerHTML = '<p style="text-align: center; color: #E74C3C; padding: 20px;">‚ùå Erreur de chargement des scores</p>';
        }
    }
    
    // √âv√©nement de changement
    select.addEventListener('change', () => loadScoresForDifficulty(select.value));
    
    // Afficher le modal et charger les scores initiaux
    showModal('scoreboardModal');
    loadScoresForDifficulty(select.value);
}
</script>
</body>
</html>
